# ==============================================================================
# SECTION 1: IMPORTS & SETUP
# ==============================================================================
import os
import sys
from concurrent.futures import ProcessPoolExecutor, as_completed
import multiprocessing
import numpy as np
import pandas as pd
import warnings
import re


from backtester import Backtester, Params

# --- PATH SETUP ---
# Add the current directory to the path to allow imports from subdirectories
try:
    current_dir = os.path.dirname(os.path.abspath(__file__))
    if current_dir not in sys.path:
        sys.path.append(current_dir)
except NameError:
    pass

# --- STRATEGY IMPORTS ---
try:
    from april.strategy import get_aprils_positions
    from john.strategy import get_johns_positions
    from william.strategy import get_williams_positions
except ImportError as e:
    print(f"FATAL ERROR: Could not import strategy files. Please check folder structure.")
    print(f"Details: {e}")
    sys.exit(1)
    
warnings.filterwarnings("ignore")

# ==============================================================================
# SECTION 2: PARALLEL BACKTESTING WORKER
# ==============================================================================
def evaluate_strategy_performance(strategy_name, strategy_function, prices_path, start_day, end_day):
    """
    Runs a backtest for a single strategy and calculates a performance score
    for each individual asset during the specified period.
    """
    print(f"--- Evaluating strategy: {strategy_name} ---")
    try:
        bt_params = Params(
            strategy_function=strategy_function, 
            start_day=1, 
            end_day=750, 
            prices_filepath=prices_path
        )
        backtester = Backtester(bt_params)
        results = backtester.run(start_day=1, end_day=750)
        
        start_index = start_day - 1
        end_index = end_day
        pnl_per_asset = results['daily_instrument_returns'][:, start_index:end_index]
        
        scores = []
        for i in range(50):
            asset_pnl = pnl_per_asset[i, :]
            if len(asset_pnl) > 0 and np.std(asset_pnl) > 0:
                score = np.mean(asset_pnl) - 0.1 * np.std(asset_pnl)
                scores.append(score)
            else:
                scores.append(-np.inf)
                
        return {strategy_name: np.array(scores)}

    except Exception as e:
        print(f"ERROR running {strategy_name}: {e}")
        return {strategy_name: np.full(50, -np.inf)}

# ==============================================================================
# SECTION 3: ALLOCATION FILE GENERATOR
# ==============================================================================
def generate_allocation_file(results_df: pd.DataFrame, output_py_path: str):
    """
    Processes the optimization results and generates a Python file
    containing the final asset allocations.
    """
    print(f"\n--- Generating allocation file: {output_py_path} ---")
    
    allocations = {'April': [], 'John': [], 'William': []}
    
    # Find the best strategy for each asset and allocate it
    results_df['BEST_STRATEGY'] = results_df.idxmax(axis=1)
    
    for index, row in results_df.iterrows():
        winner = row['BEST_STRATEGY']
        # The DataFrame index corresponds to the asset index (0-49)
        asset_index = index 
        if winner in allocations:
            allocations[winner].append(asset_index)

    # Write the lists to the output .py file
    with open(output_py_path, "w") as f:
        f.write("# This file was auto-generated by run_optimizer.py\n")
        f.write("# It contains the optimal asset allocations for each strategy.\n\n")
        f.write(f"APRILS_ASSETS = {sorted(allocations['April'])}\n\n")
        f.write(f"JOHNS_ASSETS = {sorted(allocations['John'])}\n\n")
        f.write(f"WILLIAMS_ASSETS = {sorted(allocations['William'])}\n\n")
        
    print(f"SUCCESS: Allocations saved to '{output_py_path}'")
    return results_df[['BEST_STRATEGY']]


# ==============================================================================
# SECTION 4: MAIN EXECUTION BLOCK
# ==============================================================================
if __name__ == '__main__':
    multiprocessing.freeze_support()
    
    # --- CONFIGURATION ---
    PRICES_PATH = "prices.txt"
    OPTIMIZATION_START_DAY = 600
    OPTIMIZATION_END_DAY = 750
    OUTPUT_ALLOCATION_FILE = "strategy_allocations.py"
    
    strategies_to_test = {
        "April": get_aprils_positions,
        # "John": get_johns_positions,
        "William": get_williams_positions
    }

    print(f"--- Starting Strategy Optimization for Assets ---")
    print(f"--- Evaluating performance on days {OPTIMIZATION_START_DAY}-{OPTIMIZATION_END_DAY} ---")
    all_results = {}

    # --- Run evaluations in parallel ---
    with ProcessPoolExecutor(max_workers=os.cpu_count()) as executor:
        futures = [executor.submit(evaluate_strategy_performance, name, func, PRICES_PATH, OPTIMIZATION_START_DAY, OPTIMIZATION_END_DAY) 
                   for name, func in strategies_to_test.items()]
        
        for future in as_completed(futures):
            result = future.result()
            all_results.update(result)

    # --- Generate allocation file and display summary ---
    if len(all_results) != len(strategies_to_test):
        print("\n--- ERROR: Not all strategies completed successfully. Aborting. ---")
        sys.exit(1)
        
    results_df = pd.DataFrame(all_results)
    
    final_allocations_df = generate_allocation_file(results_df, OUTPUT_ALLOCATION_FILE)
    
    print("\n--- Optimization Complete ---")
    print("Final allocation summary:")
    print(final_allocations_df['BEST_STRATEGY'].value_counts())
