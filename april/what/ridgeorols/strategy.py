import numpy as np
import statsmodels.api as sm
from sklearn.linear_model import Ridge
import sys
import os

# --- PATH SETUP ---
# Ensures the script can be loaded by a backtester in a different directory.
try:
    strategy_dir = os.path.dirname(os.path.abspath(__file__))
    if strategy_dir not in sys.path:
        sys.path.append(strategy_dir)
except NameError:
    pass

# --- DATA IMPORT ---
# This file contains the pair definitions and their initial STATIC hedge ratios,
# which should have been generated by running info_static.py.
try:
    from april.initial_static_ratios import INITIAL_STATIC_RATIOS
except ImportError:
    print("ERROR: initial_static_ratios.py not found. This strategy file requires it.")
    INITIAL_STATIC_RATIOS = []

# ==============================================================================
# SECTION 1: FINAL OPTIMIZED PARAMETERS
# ==============================================================================

# These parameters were found by grid search to be optimal for the STATIC period (Days ~151-500)
STATIC_PARAMS = {
    "ZSCORE_LOOKBACK": 150,
    "ENTRY_THRESHOLD": 0.5,
    "STOP_LOSS_THRESHOLD": 4.0,
}

# These parameters were found by grid search to be optimal for the ADAPTIVE period (Days 501-750)
ADAPTIVE_PARAMS = {
    "ZSCORE_LOOKBACK": 110,
    "ENTRY_THRESHOLD": 0.75,
    "STOP_LOSS_THRESHOLD": 4.0,
}

# --- GLOBAL STRATEGY SETTINGS ---
HEDGE_ESTIMATOR = 'ridge'      # Ridge was the winning estimator for the static period. We use it for consistency.
ADAPTIVE_START_DAY = 501       # Day to switch to the expanding window hedge ratio and ADAPTIVE_PARAMS.
POSITION_SIZE = 10000          # Dollar value for the primary asset in a pair.

# --- STATE MANAGEMENT ---
# This dictionary tracks the position state (0: flat, 1: long, -1: short) for each pair.
PAIR_POSITION_STATE = {str(info['pair']): 0 for info in INITIAL_STATIC_RATIOS}

# ==============================================================================
# SECTION 2: FINAL STRATEGY FUNCTION
# ==============================================================================
def get_aprils_positions(prcSoFar: np.ndarray) -> np.ndarray:
    """
    Implements the final, optimized hybrid pairs trading strategy.

    This strategy operates in two phases:
    1.  STATIC PHASE (< Day 501): Trades a pre-defined set of pairs using a stable,
        static hedge ratio and parameters optimized for this period.
    2.  ADAPTIVE PHASE (>= Day 501): Transitions to a robust, expanding-window
        hedge ratio and a different set of trading parameters that were
        optimized for this later period.
    
    The strategy incorporates a stateful stop-loss to manage risk on every trade.
    """
    global PAIR_POSITION_STATE

    final_positions = np.zeros(50)
    current_day = prcSoFar.shape[1]
    
    # --- Select the appropriate, optimized parameter set for the current day ---
    if current_day < ADAPTIVE_START_DAY:
        params = STATIC_PARAMS
    else:
        params = ADAPTIVE_PARAMS

    # Do not trade until we have enough data for the current period's lookback
    if current_day < params['ZSCORE_LOOKBACK']:
        return final_positions

    for pair_info in INITIAL_STATIC_RATIOS:
        pair = pair_info['pair']
        asset1_idx, asset2_idx = pair

        # --- Hedge Ratio Selection Logic ---
        if current_day < ADAPTIVE_START_DAY:
            hedge_ratio = pair_info['static_hedge_ratio']
        else:
            # Use the robust expanding window calculation with the Ridge estimator
            y = prcSoFar[asset1_idx, :]
            x = prcSoFar[asset2_idx, :].reshape(-1, 1)
            model = Ridge(alpha=1.0).fit(x, y.ravel())
            hedge_ratio = model.coef_[0]

        # --- Z-Score and Signal Generation ---
        zscore_window = prcSoFar[:, -params['ZSCORE_LOOKBACK']:]
        spread = zscore_window[asset1_idx, :] - hedge_ratio * zscore_window[asset2_idx, :]
        if np.std(spread) < 1e-6: continue
        
        current_spread = prcSoFar[asset1_idx, -1] - hedge_ratio * prcSoFar[asset2_idx, -1]
        z_score = (current_spread - np.mean(spread)) / np.std(spread)
        
        # --- Stateful Trading Logic (with Stop-Loss) ---
        pair_key = str(pair)
        current_pos = PAIR_POSITION_STATE.get(pair_key, 0)
        new_pos = current_pos

        if current_pos == 0:
            if z_score < -params['ENTRY_THRESHOLD']: new_pos = 1
            elif z_score > params['ENTRY_THRESHOLD']: new_pos = -1
        elif current_pos == 1:
            if z_score >= 0 or z_score < -params['STOP_LOSS_THRESHOLD']: new_pos = 0
        elif current_pos == -1:
            if z_score <= 0 or z_score > params['STOP_LOSS_THRESHOLD']: new_pos = 0
        
        PAIR_POSITION_STATE[pair_key] = new_pos

        # --- Calculate Final Positions ---
        if new_pos != 0:
            pos1 = new_pos * (POSITION_SIZE / prcSoFar[asset1_idx, -1])
            final_positions[asset1_idx] += pos1
            final_positions[asset2_idx] += - (pos1 * hedge_ratio * prcSoFar[asset1_idx, -1]) / prcSoFar[asset2_idx, -1]
            
    return final_positions.astype(int)